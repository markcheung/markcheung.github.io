---
layout: post
title: LeetCode 1st 50 Coding Problems
date: 2020-12-06 00:00:00-0400
description: Completed the 1st 50 coding problems.
---

{:refdef: style="text-align: center;"}
![Pie chart showing 50 problems completed](/assets/img/leet_code_first50.png){:height="90%" width="90%"}
{: refdef}
*50 done, 1577 left*


Today (actually a few weeks later) I have completed the 1st 50 problems in Leetcode, (mostly as part of the better habits initiative, i.e., fun things during breaks from deep work). I spent on average, 10 minutes on easy questions, 20 minutes on medium, and 60 minutes (or more) on hard. About half of the problems were straightforward to me. For some of the hard problems, I looked at the hints and solutions if I did not figure them out within 20 minutes (or only figuring out the brute solutions that end up being too slow) and implemented them during another break (without looking at the solutions again). I am thinking about redoing the harder ones. I am also looking into other resources (e.g., Code Forces, Google Kick Start, AtCoder, the Competitive Programmer's handbook).


Some of the problems have very interesting/optimal solutions (in terms with either time/space). I think most of the problems are fun to work out. My favorite is probably the sudoku solver, which is solved via recursion and backtracking. For some problems, I probably didn't do the way they wanted, i.e., using built-in functions like sorted to find the median of two lists.


Below is a list of what I have learned (and remembered):

* For dynamic programming, caching results can save a lot of time
* Dynamic programming can be implemented recursively (top-down) or iteratively (bottom-up)
* Expression/wildcard matching is just working out of scenarios using conditionals
* Some very clever ways of solving problems (e.g., rotate image problem has a quick solution, reverse axis, then swap indices. Finding power of a a number recursively by splitting it into two).
* Not learned here, but a great tip is to implement the brute force solutions before trying to opimize it (sometimes the way to optimize it becomes obvious after doing so, e.g., caching results).

